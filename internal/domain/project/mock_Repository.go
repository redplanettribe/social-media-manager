// Code generated by mockery v2.52.2. DO NOT EDIT.

package project

import (
	context "context"

	mock "github.com/stretchr/testify/mock"
)

// MockRepository is an autogenerated mock type for the Repository type
type MockRepository struct {
	mock.Mock
}

type MockRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockRepository) EXPECT() *MockRepository_Expecter {
	return &MockRepository_Expecter{mock: &_m.Mock}
}

// AddUserRole provides a mock function with given fields: ctx, projectID, userID, roleID
func (_m *MockRepository) AddUserRole(ctx context.Context, projectID string, userID string, roleID TeamRoleID) error {
	ret := _m.Called(ctx, projectID, userID, roleID)

	if len(ret) == 0 {
		panic("no return value specified for AddUserRole")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, TeamRoleID) error); ok {
		r0 = rf(ctx, projectID, userID, roleID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockRepository_AddUserRole_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddUserRole'
type MockRepository_AddUserRole_Call struct {
	*mock.Call
}

// AddUserRole is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID string
//   - userID string
//   - roleID TeamRoleID
func (_e *MockRepository_Expecter) AddUserRole(ctx interface{}, projectID interface{}, userID interface{}, roleID interface{}) *MockRepository_AddUserRole_Call {
	return &MockRepository_AddUserRole_Call{Call: _e.mock.On("AddUserRole", ctx, projectID, userID, roleID)}
}

func (_c *MockRepository_AddUserRole_Call) Run(run func(ctx context.Context, projectID string, userID string, roleID TeamRoleID)) *MockRepository_AddUserRole_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(TeamRoleID))
	})
	return _c
}

func (_c *MockRepository_AddUserRole_Call) Return(_a0 error) *MockRepository_AddUserRole_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockRepository_AddUserRole_Call) RunAndReturn(run func(context.Context, string, string, TeamRoleID) error) *MockRepository_AddUserRole_Call {
	_c.Call.Return(run)
	return _c
}

// AddUserToProject provides a mock function with given fields: ctx, projectID, userID
func (_m *MockRepository) AddUserToProject(ctx context.Context, projectID string, userID string) error {
	ret := _m.Called(ctx, projectID, userID)

	if len(ret) == 0 {
		panic("no return value specified for AddUserToProject")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, projectID, userID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockRepository_AddUserToProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddUserToProject'
type MockRepository_AddUserToProject_Call struct {
	*mock.Call
}

// AddUserToProject is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID string
//   - userID string
func (_e *MockRepository_Expecter) AddUserToProject(ctx interface{}, projectID interface{}, userID interface{}) *MockRepository_AddUserToProject_Call {
	return &MockRepository_AddUserToProject_Call{Call: _e.mock.On("AddUserToProject", ctx, projectID, userID)}
}

func (_c *MockRepository_AddUserToProject_Call) Run(run func(ctx context.Context, projectID string, userID string)) *MockRepository_AddUserToProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockRepository_AddUserToProject_Call) Return(_a0 error) *MockRepository_AddUserToProject_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockRepository_AddUserToProject_Call) RunAndReturn(run func(context.Context, string, string) error) *MockRepository_AddUserToProject_Call {
	_c.Call.Return(run)
	return _c
}

// AssignProjectOwner provides a mock function with given fields: ctx, projectID, userID
func (_m *MockRepository) AssignProjectOwner(ctx context.Context, projectID string, userID string) error {
	ret := _m.Called(ctx, projectID, userID)

	if len(ret) == 0 {
		panic("no return value specified for AssignProjectOwner")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, projectID, userID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockRepository_AssignProjectOwner_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssignProjectOwner'
type MockRepository_AssignProjectOwner_Call struct {
	*mock.Call
}

// AssignProjectOwner is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID string
//   - userID string
func (_e *MockRepository_Expecter) AssignProjectOwner(ctx interface{}, projectID interface{}, userID interface{}) *MockRepository_AssignProjectOwner_Call {
	return &MockRepository_AssignProjectOwner_Call{Call: _e.mock.On("AssignProjectOwner", ctx, projectID, userID)}
}

func (_c *MockRepository_AssignProjectOwner_Call) Run(run func(ctx context.Context, projectID string, userID string)) *MockRepository_AssignProjectOwner_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockRepository_AssignProjectOwner_Call) Return(_a0 error) *MockRepository_AssignProjectOwner_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockRepository_AssignProjectOwner_Call) RunAndReturn(run func(context.Context, string, string) error) *MockRepository_AssignProjectOwner_Call {
	_c.Call.Return(run)
	return _c
}

// CreateProjectSettings provides a mock function with given fields: ctx, projectID, schedule
func (_m *MockRepository) CreateProjectSettings(ctx context.Context, projectID string, schedule *WeeklyPostSchedule) error {
	ret := _m.Called(ctx, projectID, schedule)

	if len(ret) == 0 {
		panic("no return value specified for CreateProjectSettings")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *WeeklyPostSchedule) error); ok {
		r0 = rf(ctx, projectID, schedule)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockRepository_CreateProjectSettings_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateProjectSettings'
type MockRepository_CreateProjectSettings_Call struct {
	*mock.Call
}

// CreateProjectSettings is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID string
//   - schedule *WeeklyPostSchedule
func (_e *MockRepository_Expecter) CreateProjectSettings(ctx interface{}, projectID interface{}, schedule interface{}) *MockRepository_CreateProjectSettings_Call {
	return &MockRepository_CreateProjectSettings_Call{Call: _e.mock.On("CreateProjectSettings", ctx, projectID, schedule)}
}

func (_c *MockRepository_CreateProjectSettings_Call) Run(run func(ctx context.Context, projectID string, schedule *WeeklyPostSchedule)) *MockRepository_CreateProjectSettings_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*WeeklyPostSchedule))
	})
	return _c
}

func (_c *MockRepository_CreateProjectSettings_Call) Return(_a0 error) *MockRepository_CreateProjectSettings_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockRepository_CreateProjectSettings_Call) RunAndReturn(run func(context.Context, string, *WeeklyPostSchedule) error) *MockRepository_CreateProjectSettings_Call {
	_c.Call.Return(run)
	return _c
}

// Delete provides a mock function with given fields: ctx, projectID
func (_m *MockRepository) Delete(ctx context.Context, projectID string) error {
	ret := _m.Called(ctx, projectID)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, projectID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockRepository_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type MockRepository_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID string
func (_e *MockRepository_Expecter) Delete(ctx interface{}, projectID interface{}) *MockRepository_Delete_Call {
	return &MockRepository_Delete_Call{Call: _e.mock.On("Delete", ctx, projectID)}
}

func (_c *MockRepository_Delete_Call) Run(run func(ctx context.Context, projectID string)) *MockRepository_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockRepository_Delete_Call) Return(_a0 error) *MockRepository_Delete_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockRepository_Delete_Call) RunAndReturn(run func(context.Context, string) error) *MockRepository_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// DisableSocialPlatform provides a mock function with given fields: ctx, projectID, socialPlatformID
func (_m *MockRepository) DisableSocialPlatform(ctx context.Context, projectID string, socialPlatformID string) error {
	ret := _m.Called(ctx, projectID, socialPlatformID)

	if len(ret) == 0 {
		panic("no return value specified for DisableSocialPlatform")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, projectID, socialPlatformID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockRepository_DisableSocialPlatform_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DisableSocialPlatform'
type MockRepository_DisableSocialPlatform_Call struct {
	*mock.Call
}

// DisableSocialPlatform is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID string
//   - socialPlatformID string
func (_e *MockRepository_Expecter) DisableSocialPlatform(ctx interface{}, projectID interface{}, socialPlatformID interface{}) *MockRepository_DisableSocialPlatform_Call {
	return &MockRepository_DisableSocialPlatform_Call{Call: _e.mock.On("DisableSocialPlatform", ctx, projectID, socialPlatformID)}
}

func (_c *MockRepository_DisableSocialPlatform_Call) Run(run func(ctx context.Context, projectID string, socialPlatformID string)) *MockRepository_DisableSocialPlatform_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockRepository_DisableSocialPlatform_Call) Return(_a0 error) *MockRepository_DisableSocialPlatform_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockRepository_DisableSocialPlatform_Call) RunAndReturn(run func(context.Context, string, string) error) *MockRepository_DisableSocialPlatform_Call {
	_c.Call.Return(run)
	return _c
}

// DoesProjectNameExist provides a mock function with given fields: ctx, name, userID
func (_m *MockRepository) DoesProjectNameExist(ctx context.Context, name string, userID string) (bool, error) {
	ret := _m.Called(ctx, name, userID)

	if len(ret) == 0 {
		panic("no return value specified for DoesProjectNameExist")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (bool, error)); ok {
		return rf(ctx, name, userID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) bool); ok {
		r0 = rf(ctx, name, userID)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, name, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepository_DoesProjectNameExist_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DoesProjectNameExist'
type MockRepository_DoesProjectNameExist_Call struct {
	*mock.Call
}

// DoesProjectNameExist is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
//   - userID string
func (_e *MockRepository_Expecter) DoesProjectNameExist(ctx interface{}, name interface{}, userID interface{}) *MockRepository_DoesProjectNameExist_Call {
	return &MockRepository_DoesProjectNameExist_Call{Call: _e.mock.On("DoesProjectNameExist", ctx, name, userID)}
}

func (_c *MockRepository_DoesProjectNameExist_Call) Run(run func(ctx context.Context, name string, userID string)) *MockRepository_DoesProjectNameExist_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockRepository_DoesProjectNameExist_Call) Return(_a0 bool, _a1 error) *MockRepository_DoesProjectNameExist_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepository_DoesProjectNameExist_Call) RunAndReturn(run func(context.Context, string, string) (bool, error)) *MockRepository_DoesProjectNameExist_Call {
	_c.Call.Return(run)
	return _c
}

// DoesSocialPlatformExist provides a mock function with given fields: ctx, socialPlatformID
func (_m *MockRepository) DoesSocialPlatformExist(ctx context.Context, socialPlatformID string) (bool, error) {
	ret := _m.Called(ctx, socialPlatformID)

	if len(ret) == 0 {
		panic("no return value specified for DoesSocialPlatformExist")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (bool, error)); ok {
		return rf(ctx, socialPlatformID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) bool); ok {
		r0 = rf(ctx, socialPlatformID)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, socialPlatformID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepository_DoesSocialPlatformExist_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DoesSocialPlatformExist'
type MockRepository_DoesSocialPlatformExist_Call struct {
	*mock.Call
}

// DoesSocialPlatformExist is a helper method to define mock.On call
//   - ctx context.Context
//   - socialPlatformID string
func (_e *MockRepository_Expecter) DoesSocialPlatformExist(ctx interface{}, socialPlatformID interface{}) *MockRepository_DoesSocialPlatformExist_Call {
	return &MockRepository_DoesSocialPlatformExist_Call{Call: _e.mock.On("DoesSocialPlatformExist", ctx, socialPlatformID)}
}

func (_c *MockRepository_DoesSocialPlatformExist_Call) Run(run func(ctx context.Context, socialPlatformID string)) *MockRepository_DoesSocialPlatformExist_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockRepository_DoesSocialPlatformExist_Call) Return(_a0 bool, _a1 error) *MockRepository_DoesSocialPlatformExist_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepository_DoesSocialPlatformExist_Call) RunAndReturn(run func(context.Context, string) (bool, error)) *MockRepository_DoesSocialPlatformExist_Call {
	_c.Call.Return(run)
	return _c
}

// EnableSocialPlatform provides a mock function with given fields: ctx, projectID, socialPlatformID
func (_m *MockRepository) EnableSocialPlatform(ctx context.Context, projectID string, socialPlatformID string) error {
	ret := _m.Called(ctx, projectID, socialPlatformID)

	if len(ret) == 0 {
		panic("no return value specified for EnableSocialPlatform")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, projectID, socialPlatformID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockRepository_EnableSocialPlatform_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EnableSocialPlatform'
type MockRepository_EnableSocialPlatform_Call struct {
	*mock.Call
}

// EnableSocialPlatform is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID string
//   - socialPlatformID string
func (_e *MockRepository_Expecter) EnableSocialPlatform(ctx interface{}, projectID interface{}, socialPlatformID interface{}) *MockRepository_EnableSocialPlatform_Call {
	return &MockRepository_EnableSocialPlatform_Call{Call: _e.mock.On("EnableSocialPlatform", ctx, projectID, socialPlatformID)}
}

func (_c *MockRepository_EnableSocialPlatform_Call) Run(run func(ctx context.Context, projectID string, socialPlatformID string)) *MockRepository_EnableSocialPlatform_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockRepository_EnableSocialPlatform_Call) Return(_a0 error) *MockRepository_EnableSocialPlatform_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockRepository_EnableSocialPlatform_Call) RunAndReturn(run func(context.Context, string, string) error) *MockRepository_EnableSocialPlatform_Call {
	_c.Call.Return(run)
	return _c
}

// FindActiveProjectsChunk provides a mock function with given fields: ctx, limit, offset
func (_m *MockRepository) FindActiveProjectsChunk(ctx context.Context, limit int, offset int) ([]*Project, error) {
	ret := _m.Called(ctx, limit, offset)

	if len(ret) == 0 {
		panic("no return value specified for FindActiveProjectsChunk")
	}

	var r0 []*Project
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int, int) ([]*Project, error)); ok {
		return rf(ctx, limit, offset)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, int) []*Project); ok {
		r0 = rf(ctx, limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*Project)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, int) error); ok {
		r1 = rf(ctx, limit, offset)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepository_FindActiveProjectsChunk_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindActiveProjectsChunk'
type MockRepository_FindActiveProjectsChunk_Call struct {
	*mock.Call
}

// FindActiveProjectsChunk is a helper method to define mock.On call
//   - ctx context.Context
//   - limit int
//   - offset int
func (_e *MockRepository_Expecter) FindActiveProjectsChunk(ctx interface{}, limit interface{}, offset interface{}) *MockRepository_FindActiveProjectsChunk_Call {
	return &MockRepository_FindActiveProjectsChunk_Call{Call: _e.mock.On("FindActiveProjectsChunk", ctx, limit, offset)}
}

func (_c *MockRepository_FindActiveProjectsChunk_Call) Run(run func(ctx context.Context, limit int, offset int)) *MockRepository_FindActiveProjectsChunk_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(int))
	})
	return _c
}

func (_c *MockRepository_FindActiveProjectsChunk_Call) Return(_a0 []*Project, _a1 error) *MockRepository_FindActiveProjectsChunk_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepository_FindActiveProjectsChunk_Call) RunAndReturn(run func(context.Context, int, int) ([]*Project, error)) *MockRepository_FindActiveProjectsChunk_Call {
	_c.Call.Return(run)
	return _c
}

// FindProjectByID provides a mock function with given fields: ctx, projectID
func (_m *MockRepository) FindProjectByID(ctx context.Context, projectID string) (*Project, error) {
	ret := _m.Called(ctx, projectID)

	if len(ret) == 0 {
		panic("no return value specified for FindProjectByID")
	}

	var r0 *Project
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*Project, error)); ok {
		return rf(ctx, projectID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *Project); ok {
		r0 = rf(ctx, projectID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Project)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, projectID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepository_FindProjectByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindProjectByID'
type MockRepository_FindProjectByID_Call struct {
	*mock.Call
}

// FindProjectByID is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID string
func (_e *MockRepository_Expecter) FindProjectByID(ctx interface{}, projectID interface{}) *MockRepository_FindProjectByID_Call {
	return &MockRepository_FindProjectByID_Call{Call: _e.mock.On("FindProjectByID", ctx, projectID)}
}

func (_c *MockRepository_FindProjectByID_Call) Run(run func(ctx context.Context, projectID string)) *MockRepository_FindProjectByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockRepository_FindProjectByID_Call) Return(_a0 *Project, _a1 error) *MockRepository_FindProjectByID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepository_FindProjectByID_Call) RunAndReturn(run func(context.Context, string) (*Project, error)) *MockRepository_FindProjectByID_Call {
	_c.Call.Return(run)
	return _c
}

// GetDefaultUserID provides a mock function with given fields: ctx, projectID
func (_m *MockRepository) GetDefaultUserID(ctx context.Context, projectID string) (string, error) {
	ret := _m.Called(ctx, projectID)

	if len(ret) == 0 {
		panic("no return value specified for GetDefaultUserID")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (string, error)); ok {
		return rf(ctx, projectID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) string); ok {
		r0 = rf(ctx, projectID)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, projectID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepository_GetDefaultUserID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDefaultUserID'
type MockRepository_GetDefaultUserID_Call struct {
	*mock.Call
}

// GetDefaultUserID is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID string
func (_e *MockRepository_Expecter) GetDefaultUserID(ctx interface{}, projectID interface{}) *MockRepository_GetDefaultUserID_Call {
	return &MockRepository_GetDefaultUserID_Call{Call: _e.mock.On("GetDefaultUserID", ctx, projectID)}
}

func (_c *MockRepository_GetDefaultUserID_Call) Run(run func(ctx context.Context, projectID string)) *MockRepository_GetDefaultUserID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockRepository_GetDefaultUserID_Call) Return(_a0 string, _a1 error) *MockRepository_GetDefaultUserID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepository_GetDefaultUserID_Call) RunAndReturn(run func(context.Context, string) (string, error)) *MockRepository_GetDefaultUserID_Call {
	_c.Call.Return(run)
	return _c
}

// GetEnabledSocialPlatforms provides a mock function with given fields: ctx, projectID
func (_m *MockRepository) GetEnabledSocialPlatforms(ctx context.Context, projectID string) ([]SocialPlatform, error) {
	ret := _m.Called(ctx, projectID)

	if len(ret) == 0 {
		panic("no return value specified for GetEnabledSocialPlatforms")
	}

	var r0 []SocialPlatform
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) ([]SocialPlatform, error)); ok {
		return rf(ctx, projectID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) []SocialPlatform); ok {
		r0 = rf(ctx, projectID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]SocialPlatform)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, projectID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepository_GetEnabledSocialPlatforms_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEnabledSocialPlatforms'
type MockRepository_GetEnabledSocialPlatforms_Call struct {
	*mock.Call
}

// GetEnabledSocialPlatforms is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID string
func (_e *MockRepository_Expecter) GetEnabledSocialPlatforms(ctx interface{}, projectID interface{}) *MockRepository_GetEnabledSocialPlatforms_Call {
	return &MockRepository_GetEnabledSocialPlatforms_Call{Call: _e.mock.On("GetEnabledSocialPlatforms", ctx, projectID)}
}

func (_c *MockRepository_GetEnabledSocialPlatforms_Call) Run(run func(ctx context.Context, projectID string)) *MockRepository_GetEnabledSocialPlatforms_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockRepository_GetEnabledSocialPlatforms_Call) Return(_a0 []SocialPlatform, _a1 error) *MockRepository_GetEnabledSocialPlatforms_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepository_GetEnabledSocialPlatforms_Call) RunAndReturn(run func(context.Context, string) ([]SocialPlatform, error)) *MockRepository_GetEnabledSocialPlatforms_Call {
	_c.Call.Return(run)
	return _c
}

// GetPlatformInfo provides a mock function with given fields: ctx, userID, platformID
func (_m *MockRepository) GetPlatformInfo(ctx context.Context, userID string, platformID string) (*UserPlatformInfo, error) {
	ret := _m.Called(ctx, userID, platformID)

	if len(ret) == 0 {
		panic("no return value specified for GetPlatformInfo")
	}

	var r0 *UserPlatformInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (*UserPlatformInfo, error)); ok {
		return rf(ctx, userID, platformID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *UserPlatformInfo); ok {
		r0 = rf(ctx, userID, platformID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*UserPlatformInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, userID, platformID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepository_GetPlatformInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPlatformInfo'
type MockRepository_GetPlatformInfo_Call struct {
	*mock.Call
}

// GetPlatformInfo is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - platformID string
func (_e *MockRepository_Expecter) GetPlatformInfo(ctx interface{}, userID interface{}, platformID interface{}) *MockRepository_GetPlatformInfo_Call {
	return &MockRepository_GetPlatformInfo_Call{Call: _e.mock.On("GetPlatformInfo", ctx, userID, platformID)}
}

func (_c *MockRepository_GetPlatformInfo_Call) Run(run func(ctx context.Context, userID string, platformID string)) *MockRepository_GetPlatformInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockRepository_GetPlatformInfo_Call) Return(_a0 *UserPlatformInfo, _a1 error) *MockRepository_GetPlatformInfo_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepository_GetPlatformInfo_Call) RunAndReturn(run func(context.Context, string, string) (*UserPlatformInfo, error)) *MockRepository_GetPlatformInfo_Call {
	_c.Call.Return(run)
	return _c
}

// GetProjectSchedule provides a mock function with given fields: ctx, projectID
func (_m *MockRepository) GetProjectSchedule(ctx context.Context, projectID string) (*WeeklyPostSchedule, error) {
	ret := _m.Called(ctx, projectID)

	if len(ret) == 0 {
		panic("no return value specified for GetProjectSchedule")
	}

	var r0 *WeeklyPostSchedule
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*WeeklyPostSchedule, error)); ok {
		return rf(ctx, projectID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *WeeklyPostSchedule); ok {
		r0 = rf(ctx, projectID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*WeeklyPostSchedule)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, projectID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepository_GetProjectSchedule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetProjectSchedule'
type MockRepository_GetProjectSchedule_Call struct {
	*mock.Call
}

// GetProjectSchedule is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID string
func (_e *MockRepository_Expecter) GetProjectSchedule(ctx interface{}, projectID interface{}) *MockRepository_GetProjectSchedule_Call {
	return &MockRepository_GetProjectSchedule_Call{Call: _e.mock.On("GetProjectSchedule", ctx, projectID)}
}

func (_c *MockRepository_GetProjectSchedule_Call) Run(run func(ctx context.Context, projectID string)) *MockRepository_GetProjectSchedule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockRepository_GetProjectSchedule_Call) Return(_a0 *WeeklyPostSchedule, _a1 error) *MockRepository_GetProjectSchedule_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepository_GetProjectSchedule_Call) RunAndReturn(run func(context.Context, string) (*WeeklyPostSchedule, error)) *MockRepository_GetProjectSchedule_Call {
	_c.Call.Return(run)
	return _c
}

// GetProjectUsers provides a mock function with given fields: ctx, projectID
func (_m *MockRepository) GetProjectUsers(ctx context.Context, projectID string) ([]*TeamMember, error) {
	ret := _m.Called(ctx, projectID)

	if len(ret) == 0 {
		panic("no return value specified for GetProjectUsers")
	}

	var r0 []*TeamMember
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) ([]*TeamMember, error)); ok {
		return rf(ctx, projectID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) []*TeamMember); ok {
		r0 = rf(ctx, projectID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*TeamMember)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, projectID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepository_GetProjectUsers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetProjectUsers'
type MockRepository_GetProjectUsers_Call struct {
	*mock.Call
}

// GetProjectUsers is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID string
func (_e *MockRepository_Expecter) GetProjectUsers(ctx interface{}, projectID interface{}) *MockRepository_GetProjectUsers_Call {
	return &MockRepository_GetProjectUsers_Call{Call: _e.mock.On("GetProjectUsers", ctx, projectID)}
}

func (_c *MockRepository_GetProjectUsers_Call) Run(run func(ctx context.Context, projectID string)) *MockRepository_GetProjectUsers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockRepository_GetProjectUsers_Call) Return(_a0 []*TeamMember, _a1 error) *MockRepository_GetProjectUsers_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepository_GetProjectUsers_Call) RunAndReturn(run func(context.Context, string) ([]*TeamMember, error)) *MockRepository_GetProjectUsers_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserMaxRole provides a mock function with given fields: ctx, userID, projectID
func (_m *MockRepository) GetUserMaxRole(ctx context.Context, userID string, projectID string) (int, error) {
	ret := _m.Called(ctx, userID, projectID)

	if len(ret) == 0 {
		panic("no return value specified for GetUserMaxRole")
	}

	var r0 int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (int, error)); ok {
		return rf(ctx, userID, projectID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) int); ok {
		r0 = rf(ctx, userID, projectID)
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, userID, projectID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepository_GetUserMaxRole_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserMaxRole'
type MockRepository_GetUserMaxRole_Call struct {
	*mock.Call
}

// GetUserMaxRole is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - projectID string
func (_e *MockRepository_Expecter) GetUserMaxRole(ctx interface{}, userID interface{}, projectID interface{}) *MockRepository_GetUserMaxRole_Call {
	return &MockRepository_GetUserMaxRole_Call{Call: _e.mock.On("GetUserMaxRole", ctx, userID, projectID)}
}

func (_c *MockRepository_GetUserMaxRole_Call) Run(run func(ctx context.Context, userID string, projectID string)) *MockRepository_GetUserMaxRole_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockRepository_GetUserMaxRole_Call) Return(_a0 int, _a1 error) *MockRepository_GetUserMaxRole_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepository_GetUserMaxRole_Call) RunAndReturn(run func(context.Context, string, string) (int, error)) *MockRepository_GetUserMaxRole_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserRoles provides a mock function with given fields: ctx, userID, projectID
func (_m *MockRepository) GetUserRoles(ctx context.Context, userID string, projectID string) ([]string, error) {
	ret := _m.Called(ctx, userID, projectID)

	if len(ret) == 0 {
		panic("no return value specified for GetUserRoles")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) ([]string, error)); ok {
		return rf(ctx, userID, projectID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) []string); ok {
		r0 = rf(ctx, userID, projectID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, userID, projectID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepository_GetUserRoles_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserRoles'
type MockRepository_GetUserRoles_Call struct {
	*mock.Call
}

// GetUserRoles is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - projectID string
func (_e *MockRepository_Expecter) GetUserRoles(ctx interface{}, userID interface{}, projectID interface{}) *MockRepository_GetUserRoles_Call {
	return &MockRepository_GetUserRoles_Call{Call: _e.mock.On("GetUserRoles", ctx, userID, projectID)}
}

func (_c *MockRepository_GetUserRoles_Call) Run(run func(ctx context.Context, userID string, projectID string)) *MockRepository_GetUserRoles_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockRepository_GetUserRoles_Call) Return(_a0 []string, _a1 error) *MockRepository_GetUserRoles_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepository_GetUserRoles_Call) RunAndReturn(run func(context.Context, string, string) ([]string, error)) *MockRepository_GetUserRoles_Call {
	_c.Call.Return(run)
	return _c
}

// IsProjectSocialPlatformEnabled provides a mock function with given fields: ctx, projectID, socialPlatformID
func (_m *MockRepository) IsProjectSocialPlatformEnabled(ctx context.Context, projectID string, socialPlatformID string) (bool, error) {
	ret := _m.Called(ctx, projectID, socialPlatformID)

	if len(ret) == 0 {
		panic("no return value specified for IsProjectSocialPlatformEnabled")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (bool, error)); ok {
		return rf(ctx, projectID, socialPlatformID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) bool); ok {
		r0 = rf(ctx, projectID, socialPlatformID)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, projectID, socialPlatformID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepository_IsProjectSocialPlatformEnabled_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsProjectSocialPlatformEnabled'
type MockRepository_IsProjectSocialPlatformEnabled_Call struct {
	*mock.Call
}

// IsProjectSocialPlatformEnabled is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID string
//   - socialPlatformID string
func (_e *MockRepository_Expecter) IsProjectSocialPlatformEnabled(ctx interface{}, projectID interface{}, socialPlatformID interface{}) *MockRepository_IsProjectSocialPlatformEnabled_Call {
	return &MockRepository_IsProjectSocialPlatformEnabled_Call{Call: _e.mock.On("IsProjectSocialPlatformEnabled", ctx, projectID, socialPlatformID)}
}

func (_c *MockRepository_IsProjectSocialPlatformEnabled_Call) Run(run func(ctx context.Context, projectID string, socialPlatformID string)) *MockRepository_IsProjectSocialPlatformEnabled_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockRepository_IsProjectSocialPlatformEnabled_Call) Return(_a0 bool, _a1 error) *MockRepository_IsProjectSocialPlatformEnabled_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepository_IsProjectSocialPlatformEnabled_Call) RunAndReturn(run func(context.Context, string, string) (bool, error)) *MockRepository_IsProjectSocialPlatformEnabled_Call {
	_c.Call.Return(run)
	return _c
}

// IsUserInProject provides a mock function with given fields: ctx, projectID, userID
func (_m *MockRepository) IsUserInProject(ctx context.Context, projectID string, userID string) (bool, error) {
	ret := _m.Called(ctx, projectID, userID)

	if len(ret) == 0 {
		panic("no return value specified for IsUserInProject")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (bool, error)); ok {
		return rf(ctx, projectID, userID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) bool); ok {
		r0 = rf(ctx, projectID, userID)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, projectID, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepository_IsUserInProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsUserInProject'
type MockRepository_IsUserInProject_Call struct {
	*mock.Call
}

// IsUserInProject is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID string
//   - userID string
func (_e *MockRepository_Expecter) IsUserInProject(ctx interface{}, projectID interface{}, userID interface{}) *MockRepository_IsUserInProject_Call {
	return &MockRepository_IsUserInProject_Call{Call: _e.mock.On("IsUserInProject", ctx, projectID, userID)}
}

func (_c *MockRepository_IsUserInProject_Call) Run(run func(ctx context.Context, projectID string, userID string)) *MockRepository_IsUserInProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockRepository_IsUserInProject_Call) Return(_a0 bool, _a1 error) *MockRepository_IsUserInProject_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepository_IsUserInProject_Call) RunAndReturn(run func(context.Context, string, string) (bool, error)) *MockRepository_IsUserInProject_Call {
	_c.Call.Return(run)
	return _c
}

// ListByUserID provides a mock function with given fields: ctx, userID
func (_m *MockRepository) ListByUserID(ctx context.Context, userID string) ([]*Project, error) {
	ret := _m.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for ListByUserID")
	}

	var r0 []*Project
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) ([]*Project, error)); ok {
		return rf(ctx, userID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) []*Project); ok {
		r0 = rf(ctx, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*Project)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepository_ListByUserID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListByUserID'
type MockRepository_ListByUserID_Call struct {
	*mock.Call
}

// ListByUserID is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
func (_e *MockRepository_Expecter) ListByUserID(ctx interface{}, userID interface{}) *MockRepository_ListByUserID_Call {
	return &MockRepository_ListByUserID_Call{Call: _e.mock.On("ListByUserID", ctx, userID)}
}

func (_c *MockRepository_ListByUserID_Call) Run(run func(ctx context.Context, userID string)) *MockRepository_ListByUserID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockRepository_ListByUserID_Call) Return(_a0 []*Project, _a1 error) *MockRepository_ListByUserID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepository_ListByUserID_Call) RunAndReturn(run func(context.Context, string) ([]*Project, error)) *MockRepository_ListByUserID_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveUserFromProject provides a mock function with given fields: ctx, projectID, userID
func (_m *MockRepository) RemoveUserFromProject(ctx context.Context, projectID string, userID string) error {
	ret := _m.Called(ctx, projectID, userID)

	if len(ret) == 0 {
		panic("no return value specified for RemoveUserFromProject")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, projectID, userID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockRepository_RemoveUserFromProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveUserFromProject'
type MockRepository_RemoveUserFromProject_Call struct {
	*mock.Call
}

// RemoveUserFromProject is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID string
//   - userID string
func (_e *MockRepository_Expecter) RemoveUserFromProject(ctx interface{}, projectID interface{}, userID interface{}) *MockRepository_RemoveUserFromProject_Call {
	return &MockRepository_RemoveUserFromProject_Call{Call: _e.mock.On("RemoveUserFromProject", ctx, projectID, userID)}
}

func (_c *MockRepository_RemoveUserFromProject_Call) Run(run func(ctx context.Context, projectID string, userID string)) *MockRepository_RemoveUserFromProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockRepository_RemoveUserFromProject_Call) Return(_a0 error) *MockRepository_RemoveUserFromProject_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockRepository_RemoveUserFromProject_Call) RunAndReturn(run func(context.Context, string, string) error) *MockRepository_RemoveUserFromProject_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveUserRole provides a mock function with given fields: ctx, projectID, userID, roleID
func (_m *MockRepository) RemoveUserRole(ctx context.Context, projectID string, userID string, roleID TeamRoleID) error {
	ret := _m.Called(ctx, projectID, userID, roleID)

	if len(ret) == 0 {
		panic("no return value specified for RemoveUserRole")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, TeamRoleID) error); ok {
		r0 = rf(ctx, projectID, userID, roleID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockRepository_RemoveUserRole_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveUserRole'
type MockRepository_RemoveUserRole_Call struct {
	*mock.Call
}

// RemoveUserRole is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID string
//   - userID string
//   - roleID TeamRoleID
func (_e *MockRepository_Expecter) RemoveUserRole(ctx interface{}, projectID interface{}, userID interface{}, roleID interface{}) *MockRepository_RemoveUserRole_Call {
	return &MockRepository_RemoveUserRole_Call{Call: _e.mock.On("RemoveUserRole", ctx, projectID, userID, roleID)}
}

func (_c *MockRepository_RemoveUserRole_Call) Run(run func(ctx context.Context, projectID string, userID string, roleID TeamRoleID)) *MockRepository_RemoveUserRole_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(TeamRoleID))
	})
	return _c
}

func (_c *MockRepository_RemoveUserRole_Call) Return(_a0 error) *MockRepository_RemoveUserRole_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockRepository_RemoveUserRole_Call) RunAndReturn(run func(context.Context, string, string, TeamRoleID) error) *MockRepository_RemoveUserRole_Call {
	_c.Call.Return(run)
	return _c
}

// Save provides a mock function with given fields: ctx, _a1
func (_m *MockRepository) Save(ctx context.Context, _a1 *Project) (*Project, error) {
	ret := _m.Called(ctx, _a1)

	if len(ret) == 0 {
		panic("no return value specified for Save")
	}

	var r0 *Project
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *Project) (*Project, error)); ok {
		return rf(ctx, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *Project) *Project); ok {
		r0 = rf(ctx, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Project)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *Project) error); ok {
		r1 = rf(ctx, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepository_Save_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Save'
type MockRepository_Save_Call struct {
	*mock.Call
}

// Save is a helper method to define mock.On call
//   - ctx context.Context
//   - _a1 *Project
func (_e *MockRepository_Expecter) Save(ctx interface{}, _a1 interface{}) *MockRepository_Save_Call {
	return &MockRepository_Save_Call{Call: _e.mock.On("Save", ctx, _a1)}
}

func (_c *MockRepository_Save_Call) Run(run func(ctx context.Context, _a1 *Project)) *MockRepository_Save_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*Project))
	})
	return _c
}

func (_c *MockRepository_Save_Call) Return(_a0 *Project, _a1 error) *MockRepository_Save_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepository_Save_Call) RunAndReturn(run func(context.Context, *Project) (*Project, error)) *MockRepository_Save_Call {
	_c.Call.Return(run)
	return _c
}

// SaveSchedule provides a mock function with given fields: ctx, projectID, schedule
func (_m *MockRepository) SaveSchedule(ctx context.Context, projectID string, schedule *WeeklyPostSchedule) error {
	ret := _m.Called(ctx, projectID, schedule)

	if len(ret) == 0 {
		panic("no return value specified for SaveSchedule")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *WeeklyPostSchedule) error); ok {
		r0 = rf(ctx, projectID, schedule)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockRepository_SaveSchedule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SaveSchedule'
type MockRepository_SaveSchedule_Call struct {
	*mock.Call
}

// SaveSchedule is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID string
//   - schedule *WeeklyPostSchedule
func (_e *MockRepository_Expecter) SaveSchedule(ctx interface{}, projectID interface{}, schedule interface{}) *MockRepository_SaveSchedule_Call {
	return &MockRepository_SaveSchedule_Call{Call: _e.mock.On("SaveSchedule", ctx, projectID, schedule)}
}

func (_c *MockRepository_SaveSchedule_Call) Run(run func(ctx context.Context, projectID string, schedule *WeeklyPostSchedule)) *MockRepository_SaveSchedule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*WeeklyPostSchedule))
	})
	return _c
}

func (_c *MockRepository_SaveSchedule_Call) Return(_a0 error) *MockRepository_SaveSchedule_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockRepository_SaveSchedule_Call) RunAndReturn(run func(context.Context, string, *WeeklyPostSchedule) error) *MockRepository_SaveSchedule_Call {
	_c.Call.Return(run)
	return _c
}

// SetDefaultUser provides a mock function with given fields: ctx, projectID, userID
func (_m *MockRepository) SetDefaultUser(ctx context.Context, projectID string, userID string) error {
	ret := _m.Called(ctx, projectID, userID)

	if len(ret) == 0 {
		panic("no return value specified for SetDefaultUser")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, projectID, userID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockRepository_SetDefaultUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetDefaultUser'
type MockRepository_SetDefaultUser_Call struct {
	*mock.Call
}

// SetDefaultUser is a helper method to define mock.On call
//   - ctx context.Context
//   - projectID string
//   - userID string
func (_e *MockRepository_Expecter) SetDefaultUser(ctx interface{}, projectID interface{}, userID interface{}) *MockRepository_SetDefaultUser_Call {
	return &MockRepository_SetDefaultUser_Call{Call: _e.mock.On("SetDefaultUser", ctx, projectID, userID)}
}

func (_c *MockRepository_SetDefaultUser_Call) Run(run func(ctx context.Context, projectID string, userID string)) *MockRepository_SetDefaultUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockRepository_SetDefaultUser_Call) Return(_a0 error) *MockRepository_SetDefaultUser_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockRepository_SetDefaultUser_Call) RunAndReturn(run func(context.Context, string, string) error) *MockRepository_SetDefaultUser_Call {
	_c.Call.Return(run)
	return _c
}

// Update provides a mock function with given fields: ctx, _a1
func (_m *MockRepository) Update(ctx context.Context, _a1 *Project) (*Project, error) {
	ret := _m.Called(ctx, _a1)

	if len(ret) == 0 {
		panic("no return value specified for Update")
	}

	var r0 *Project
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *Project) (*Project, error)); ok {
		return rf(ctx, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *Project) *Project); ok {
		r0 = rf(ctx, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Project)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *Project) error); ok {
		r1 = rf(ctx, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepository_Update_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Update'
type MockRepository_Update_Call struct {
	*mock.Call
}

// Update is a helper method to define mock.On call
//   - ctx context.Context
//   - _a1 *Project
func (_e *MockRepository_Expecter) Update(ctx interface{}, _a1 interface{}) *MockRepository_Update_Call {
	return &MockRepository_Update_Call{Call: _e.mock.On("Update", ctx, _a1)}
}

func (_c *MockRepository_Update_Call) Run(run func(ctx context.Context, _a1 *Project)) *MockRepository_Update_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*Project))
	})
	return _c
}

func (_c *MockRepository_Update_Call) Return(_a0 *Project, _a1 error) *MockRepository_Update_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepository_Update_Call) RunAndReturn(run func(context.Context, *Project) (*Project, error)) *MockRepository_Update_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockRepository creates a new instance of MockRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockRepository {
	mock := &MockRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
