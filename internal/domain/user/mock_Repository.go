// Code generated by mockery v2.52.2. DO NOT EDIT.

package user

import (
	context "context"

	mock "github.com/stretchr/testify/mock"
)

// MockRepository is an autogenerated mock type for the Repository type
type MockRepository struct {
	mock.Mock
}

type MockRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockRepository) EXPECT() *MockRepository_Expecter {
	return &MockRepository_Expecter{mock: &_m.Mock}
}

// AssignDefaultRoleToUser provides a mock function with given fields: ctx, userID
func (_m *MockRepository) AssignDefaultRoleToUser(ctx context.Context, userID string) error {
	ret := _m.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for AssignDefaultRoleToUser")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, userID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockRepository_AssignDefaultRoleToUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssignDefaultRoleToUser'
type MockRepository_AssignDefaultRoleToUser_Call struct {
	*mock.Call
}

// AssignDefaultRoleToUser is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
func (_e *MockRepository_Expecter) AssignDefaultRoleToUser(ctx interface{}, userID interface{}) *MockRepository_AssignDefaultRoleToUser_Call {
	return &MockRepository_AssignDefaultRoleToUser_Call{Call: _e.mock.On("AssignDefaultRoleToUser", ctx, userID)}
}

func (_c *MockRepository_AssignDefaultRoleToUser_Call) Run(run func(ctx context.Context, userID string)) *MockRepository_AssignDefaultRoleToUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockRepository_AssignDefaultRoleToUser_Call) Return(_a0 error) *MockRepository_AssignDefaultRoleToUser_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockRepository_AssignDefaultRoleToUser_Call) RunAndReturn(run func(context.Context, string) error) *MockRepository_AssignDefaultRoleToUser_Call {
	_c.Call.Return(run)
	return _c
}

// AssignRoleToUser provides a mock function with given fields: ctx, userID, roleID
func (_m *MockRepository) AssignRoleToUser(ctx context.Context, userID string, roleID string) error {
	ret := _m.Called(ctx, userID, roleID)

	if len(ret) == 0 {
		panic("no return value specified for AssignRoleToUser")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, userID, roleID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockRepository_AssignRoleToUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssignRoleToUser'
type MockRepository_AssignRoleToUser_Call struct {
	*mock.Call
}

// AssignRoleToUser is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - roleID string
func (_e *MockRepository_Expecter) AssignRoleToUser(ctx interface{}, userID interface{}, roleID interface{}) *MockRepository_AssignRoleToUser_Call {
	return &MockRepository_AssignRoleToUser_Call{Call: _e.mock.On("AssignRoleToUser", ctx, userID, roleID)}
}

func (_c *MockRepository_AssignRoleToUser_Call) Run(run func(ctx context.Context, userID string, roleID string)) *MockRepository_AssignRoleToUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockRepository_AssignRoleToUser_Call) Return(_a0 error) *MockRepository_AssignRoleToUser_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockRepository_AssignRoleToUser_Call) RunAndReturn(run func(context.Context, string, string) error) *MockRepository_AssignRoleToUser_Call {
	_c.Call.Return(run)
	return _c
}

// FindByEmail provides a mock function with given fields: ctx, email
func (_m *MockRepository) FindByEmail(ctx context.Context, email string) (*FullUserResponse, error) {
	ret := _m.Called(ctx, email)

	if len(ret) == 0 {
		panic("no return value specified for FindByEmail")
	}

	var r0 *FullUserResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*FullUserResponse, error)); ok {
		return rf(ctx, email)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *FullUserResponse); ok {
		r0 = rf(ctx, email)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*FullUserResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, email)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepository_FindByEmail_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindByEmail'
type MockRepository_FindByEmail_Call struct {
	*mock.Call
}

// FindByEmail is a helper method to define mock.On call
//   - ctx context.Context
//   - email string
func (_e *MockRepository_Expecter) FindByEmail(ctx interface{}, email interface{}) *MockRepository_FindByEmail_Call {
	return &MockRepository_FindByEmail_Call{Call: _e.mock.On("FindByEmail", ctx, email)}
}

func (_c *MockRepository_FindByEmail_Call) Run(run func(ctx context.Context, email string)) *MockRepository_FindByEmail_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockRepository_FindByEmail_Call) Return(_a0 *FullUserResponse, _a1 error) *MockRepository_FindByEmail_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepository_FindByEmail_Call) RunAndReturn(run func(context.Context, string) (*FullUserResponse, error)) *MockRepository_FindByEmail_Call {
	_c.Call.Return(run)
	return _c
}

// FindByID provides a mock function with given fields: ctx, id
func (_m *MockRepository) FindByID(ctx context.Context, id string) (*UserResponse, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for FindByID")
	}

	var r0 *UserResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*UserResponse, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *UserResponse); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*UserResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepository_FindByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindByID'
type MockRepository_FindByID_Call struct {
	*mock.Call
}

// FindByID is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *MockRepository_Expecter) FindByID(ctx interface{}, id interface{}) *MockRepository_FindByID_Call {
	return &MockRepository_FindByID_Call{Call: _e.mock.On("FindByID", ctx, id)}
}

func (_c *MockRepository_FindByID_Call) Run(run func(ctx context.Context, id string)) *MockRepository_FindByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockRepository_FindByID_Call) Return(_a0 *UserResponse, _a1 error) *MockRepository_FindByID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepository_FindByID_Call) RunAndReturn(run func(context.Context, string) (*UserResponse, error)) *MockRepository_FindByID_Call {
	_c.Call.Return(run)
	return _c
}

// FindByIDWithRoles provides a mock function with given fields: ctx, id
func (_m *MockRepository) FindByIDWithRoles(ctx context.Context, id string) (*UserResponse, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for FindByIDWithRoles")
	}

	var r0 *UserResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*UserResponse, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *UserResponse); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*UserResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepository_FindByIDWithRoles_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindByIDWithRoles'
type MockRepository_FindByIDWithRoles_Call struct {
	*mock.Call
}

// FindByIDWithRoles is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *MockRepository_Expecter) FindByIDWithRoles(ctx interface{}, id interface{}) *MockRepository_FindByIDWithRoles_Call {
	return &MockRepository_FindByIDWithRoles_Call{Call: _e.mock.On("FindByIDWithRoles", ctx, id)}
}

func (_c *MockRepository_FindByIDWithRoles_Call) Run(run func(ctx context.Context, id string)) *MockRepository_FindByIDWithRoles_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockRepository_FindByIDWithRoles_Call) Return(_a0 *UserResponse, _a1 error) *MockRepository_FindByIDWithRoles_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepository_FindByIDWithRoles_Call) RunAndReturn(run func(context.Context, string) (*UserResponse, error)) *MockRepository_FindByIDWithRoles_Call {
	_c.Call.Return(run)
	return _c
}

// FindByUsernameOrEmail provides a mock function with given fields: ctx, username, email
func (_m *MockRepository) FindByUsernameOrEmail(ctx context.Context, username string, email string) (*UserResponse, error) {
	ret := _m.Called(ctx, username, email)

	if len(ret) == 0 {
		panic("no return value specified for FindByUsernameOrEmail")
	}

	var r0 *UserResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (*UserResponse, error)); ok {
		return rf(ctx, username, email)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *UserResponse); ok {
		r0 = rf(ctx, username, email)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*UserResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, username, email)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepository_FindByUsernameOrEmail_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindByUsernameOrEmail'
type MockRepository_FindByUsernameOrEmail_Call struct {
	*mock.Call
}

// FindByUsernameOrEmail is a helper method to define mock.On call
//   - ctx context.Context
//   - username string
//   - email string
func (_e *MockRepository_Expecter) FindByUsernameOrEmail(ctx interface{}, username interface{}, email interface{}) *MockRepository_FindByUsernameOrEmail_Call {
	return &MockRepository_FindByUsernameOrEmail_Call{Call: _e.mock.On("FindByUsernameOrEmail", ctx, username, email)}
}

func (_c *MockRepository_FindByUsernameOrEmail_Call) Run(run func(ctx context.Context, username string, email string)) *MockRepository_FindByUsernameOrEmail_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockRepository_FindByUsernameOrEmail_Call) Return(_a0 *UserResponse, _a1 error) *MockRepository_FindByUsernameOrEmail_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepository_FindByUsernameOrEmail_Call) RunAndReturn(run func(context.Context, string, string) (*UserResponse, error)) *MockRepository_FindByUsernameOrEmail_Call {
	_c.Call.Return(run)
	return _c
}

// GetRoles provides a mock function with given fields: ctx
func (_m *MockRepository) GetRoles(ctx context.Context) (*[]AppRole, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetRoles")
	}

	var r0 *[]AppRole
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*[]AppRole, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *[]AppRole); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*[]AppRole)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepository_GetRoles_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRoles'
type MockRepository_GetRoles_Call struct {
	*mock.Call
}

// GetRoles is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockRepository_Expecter) GetRoles(ctx interface{}) *MockRepository_GetRoles_Call {
	return &MockRepository_GetRoles_Call{Call: _e.mock.On("GetRoles", ctx)}
}

func (_c *MockRepository_GetRoles_Call) Run(run func(ctx context.Context)) *MockRepository_GetRoles_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockRepository_GetRoles_Call) Return(_a0 *[]AppRole, _a1 error) *MockRepository_GetRoles_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepository_GetRoles_Call) RunAndReturn(run func(context.Context) (*[]AppRole, error)) *MockRepository_GetRoles_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserRoles provides a mock function with given fields: ctx, userID
func (_m *MockRepository) GetUserRoles(ctx context.Context, userID string) ([]string, error) {
	ret := _m.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for GetUserRoles")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) ([]string, error)); ok {
		return rf(ctx, userID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) []string); ok {
		r0 = rf(ctx, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepository_GetUserRoles_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserRoles'
type MockRepository_GetUserRoles_Call struct {
	*mock.Call
}

// GetUserRoles is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
func (_e *MockRepository_Expecter) GetUserRoles(ctx interface{}, userID interface{}) *MockRepository_GetUserRoles_Call {
	return &MockRepository_GetUserRoles_Call{Call: _e.mock.On("GetUserRoles", ctx, userID)}
}

func (_c *MockRepository_GetUserRoles_Call) Run(run func(ctx context.Context, userID string)) *MockRepository_GetUserRoles_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockRepository_GetUserRoles_Call) Return(_a0 []string, _a1 error) *MockRepository_GetUserRoles_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepository_GetUserRoles_Call) RunAndReturn(run func(context.Context, string) ([]string, error)) *MockRepository_GetUserRoles_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveRoleFromUser provides a mock function with given fields: ctx, userID, roleID
func (_m *MockRepository) RemoveRoleFromUser(ctx context.Context, userID string, roleID string) error {
	ret := _m.Called(ctx, userID, roleID)

	if len(ret) == 0 {
		panic("no return value specified for RemoveRoleFromUser")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, userID, roleID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockRepository_RemoveRoleFromUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveRoleFromUser'
type MockRepository_RemoveRoleFromUser_Call struct {
	*mock.Call
}

// RemoveRoleFromUser is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - roleID string
func (_e *MockRepository_Expecter) RemoveRoleFromUser(ctx interface{}, userID interface{}, roleID interface{}) *MockRepository_RemoveRoleFromUser_Call {
	return &MockRepository_RemoveRoleFromUser_Call{Call: _e.mock.On("RemoveRoleFromUser", ctx, userID, roleID)}
}

func (_c *MockRepository_RemoveRoleFromUser_Call) Run(run func(ctx context.Context, userID string, roleID string)) *MockRepository_RemoveRoleFromUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockRepository_RemoveRoleFromUser_Call) Return(_a0 error) *MockRepository_RemoveRoleFromUser_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockRepository_RemoveRoleFromUser_Call) RunAndReturn(run func(context.Context, string, string) error) *MockRepository_RemoveRoleFromUser_Call {
	_c.Call.Return(run)
	return _c
}

// Save provides a mock function with given fields: ctx, usr
func (_m *MockRepository) Save(ctx context.Context, usr *User) (*UserResponse, error) {
	ret := _m.Called(ctx, usr)

	if len(ret) == 0 {
		panic("no return value specified for Save")
	}

	var r0 *UserResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *User) (*UserResponse, error)); ok {
		return rf(ctx, usr)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *User) *UserResponse); ok {
		r0 = rf(ctx, usr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*UserResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *User) error); ok {
		r1 = rf(ctx, usr)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepository_Save_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Save'
type MockRepository_Save_Call struct {
	*mock.Call
}

// Save is a helper method to define mock.On call
//   - ctx context.Context
//   - usr *User
func (_e *MockRepository_Expecter) Save(ctx interface{}, usr interface{}) *MockRepository_Save_Call {
	return &MockRepository_Save_Call{Call: _e.mock.On("Save", ctx, usr)}
}

func (_c *MockRepository_Save_Call) Run(run func(ctx context.Context, usr *User)) *MockRepository_Save_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*User))
	})
	return _c
}

func (_c *MockRepository_Save_Call) Return(_a0 *UserResponse, _a1 error) *MockRepository_Save_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepository_Save_Call) RunAndReturn(run func(context.Context, *User) (*UserResponse, error)) *MockRepository_Save_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockRepository creates a new instance of MockRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockRepository {
	mock := &MockRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
